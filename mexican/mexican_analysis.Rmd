---
title: "Mexican Analysis"
output: html_notebook
---


```{r}
library("data.table")
library("ggplot2")
library('Matrix')
library("splines")
theme_set(theme_bw())
function_dir <- "../functions/"
sapply(list.files(function_dir), function(xx) source(paste0(function_dir, xx)))
```

### Setup

#### Plink Stuff
Download the Data here!

http://data.inmegen.gob.mx/

Map Files have Exactly 4 columns:
  * chromosome
  * rs# or SNP identifier
  * Genetic Distance (morgans)
  * Basepair Position (bp units)
  
PED files have 6+ columns, but the first 6 are:
  * Family ID
  * Individual ID
  * Paternal ID
  * Maternal ID
  * Sex (1=Male, 2=Female, other=Unknown)
  * Phenotype (only one phenotype in this column)

Download CEU Data from HapMap:

```{bash, eval = F}
plink 
  --bfile hapmap_CEU_r23a #bim file
  --filter-males #filtering only males
  --chr X #filter out only chromosome X
  --geno 0.20 
  --hwe 0.0001 
  --recode 
  --allele1234 #convert from ACTG -> 1234
  --out CEU 
  --noweb
```

```
plink --bfile hapmap_CEU_r23a --chr X  --geno 0.20 --hwe 0.0001 --recode --allele1234 --out CEU_all --noweb
```

Only SNPs with a missingness 20%, Hardyâ€“Weinberg equilibrium P value 0.0001, and HET 1% in chromosome X of males were included in our analysis.  Merge all the files first and output into `merged.ped` and `merged.map`

```
# all_files.txt

GUE.ped GUE.map
SON.ped SON.map
VER.ped VER.map
YUC.ped YUC.map
ZAC.ped ZAC.map
ZAP.ped ZAP.map
CEU.ped CEU.map
```


```{bash, eval = F}
plink --file GUA --merge-list all_files.txt --geno 0.20 --hwe 0.0001 --filter-males --chr X --noweb --het --recode --tab --out merged

plink --file GUA --merge-list all_files_all_gender.txt --geno 0.20 --hwe 0.0001 --chr X --noweb --het --recode12 --tab --out merged_all_gender
```

```
225181 SNPs failed missingness test ( GENO > 0.2 )
0 SNPs failed frequency test ( MAF < 0 )
After frequency and genotyping pruning, there are 2297 SNPs
After filtering, 0 cases, 146 controls and 61 missing
After filtering, 207 males, 0 females, and 0 of unspecified sex
Writing recoded ped file to [ merged.ped ]
Writing new map file to [ merged.map ]

Analysis finished: Mon Dec  2 13:30:39 2019
```
Convert the -9's in the phenotype column (missing phenotypes) in the ped file to 1 so `convertf` doesn't mess up

```{bash, eval = F}
 awk '{print $6}' merged.ped
```

grab the observation names:

```{bash, eval = F}
cut -f1 merged.ped > merged_names
cut -f1 merged_all_gender.ped > merged_all_gender_names
```

use `convertf` to change from `.ped` file to `.geno` of eignestrat format

```{bash, eval = F}
convertf -p par.PED.EIGENSTRAT
```

```
# par.PED.EIGENSTRAT

genotypename:    merged.ped
snpname:         merged.map # or example.map, either works
indivname:       merged.ped # or example.ped, either works
outputformat:    EIGENSTRAT
genotypeoutname: merged.geno
snpoutname:      merged.snp
indivoutname:    merged.ind
familynames:     NO
```

https://www.pnas.org/content/suppl/2009/05/11/0903045106.DCSupplemental/0903045106SI.pdf#nameddest=STXT

```
# cut {GUA,GUE,SON,VER,YUC,ZAC,ZAP,CEU}.ped -f1 -d' ' > ethnic_group
# cut merged_tab_recoded.ped -f1 > merged_col_ID 
#  wc -l {GUA,GUE,SON,VER,YUC,ZAC,ZAP,CEU}.ped
50 GUA.ped
50 GUE.ped
50 SON.ped
50 VER.ped
50 YUC.ped
50 ZAC.ped
30 ZAP.ped
44 CEU.ped
374 total
```

```{R}
temp <- fread("merged.geno", header = F) # 2297 SNPs x 207 Sample ID
temp_names <- fread("merged_names", header = F) #Sample ID

# transforming data into a usable data.table
geno_to_R = function(data_table){
data_table <- data_table[, tstrsplit(V1, "", fixed=TRUE)][,lapply(.SD, as.numeric)]
  }
temp <- geno_to_R(temp)

#creating a lookup table to figure out which ethnic group the samples belong to
ethnic_grp <- fread("ethnic_group", header = F) #
mex_group <- c("GUA","GUE","SON", "VER", "YUC", "ZAC")
mex_grp_names <- c(sapply(mex_group, function(xx) paste0(xx ,"_", 1:50)), paste0("ZAP_", 1:30), paste0("CEU", 1:44))

#using the lookup table to identify sample ethnic group
patient_key <- cbind(ethnic_grp, substr(mex_grp_names, 1, 3))
setnames(patient_key, c("ID","group"))
mex_grp_dat <- patient_key[ID %in% temp_names$V1, .N, by = group]

subset_mex_grp_names <- mex_grp_dat[ , paste0(rep(group, N),"_", N)]
setnames(temp, subset_mex_grp_names)

```

### Imputation scheme

sample missing values uniformly from the discrete distribution of the SNP that aren't missing.

```{R}
set.seed(3141)
t_temp <- data.table(t(temp))

# which SNPs have missing values in them
imputed_cols <- t_temp[, which(lapply(.SD, function(zz) sum(zz == 9)) > 0)]

#index at those SNPs that have missing values
list_missing_loc <- t_temp[,.SD, .SDcols = imputed_cols][, .(lapply(.SD, function(zz) which(zz == 9)))][[1]]

for(jj in seq_along(imputed_cols)){

idx_replace <- list_missing_loc[[jj]]
which_col <-  names(imputed_cols[jj])

#getting the distribution for the particular SNP
snp_table <-t_temp[, .("0" = mean(.SD == 0),"1" = mean(.SD == 1), "2" = mean(.SD == 2)), .SDcols = which_col]

# sampling from the distribution for that SNP (0, 1, or 2) based on other samples
sim <- sample(
  x = as.numeric(names(snp_table)),
  prob = as.vector(snp_table),
  size = length(idx_replace),
  replace = T
)
#replacing the index and column with resampled
  t_temp[idx_replace, (which_col):= sim]
}

imputed_dat <- data.table(t(t_temp))
setnames(imputed_dat, subset_mex_grp_names)

fwrite(imputed_dat, "sub_imputed_data_sampling_dist.csv")
#imputed_dat <- fread("sub_imputed_data_sampling_dist.csv")
```

Use mean to impute instead of sampling from the sampling distribution

```{R}
t_temp <- data.table(t(temp))

# which SNPs have missing values in them
imputed_cols <- t_temp[, which(lapply(.SD, function(zz) sum(zz == 9)) > 0)]

#index at those SNPs that have missing values
list_missing_loc <- t_temp[,.SD, .SDcols = imputed_cols][, .(lapply(.SD, function(zz) which(zz == 9)))][[1]]

for(jj in seq_along(imputed_cols)){
  idx_replace <- list_missing_loc[[jj]]
  which_col <-  names(imputed_cols[jj])

#getting the mean for the particular SNP without the missing values
all_snp_vals <- t_temp[, unlist(.SD), .SDcols = which_col]

#replacing the index 
  t_temp[idx_replace, (which_col):= mean(all_snp_vals[which(all_snp_vals!=9)]) ]
}

imputed_mean_dat <- data.table(t(t_temp))

setnames(imputed_mean_dat, subset_mex_grp_names)
fwrite(imputed_mean_dat, "sub_imputed_mean_data.csv")
#imputed_mean_dat <- fread("sub_imputed_mean_data.csv")
```

double checking imputation results

```{R}
#before dist. imputation
length(imputed_cols);

#after dist. imputation
t_temp[, sum(lapply(.SD, function(zz) sum(zz == 9)) > 0)]

#SNP means, before and after imputation. should all be positive cause 9's inflate the mean
boxplot(rowMeans(temp) - rowMeans(imputed_mean_dat))

#imputation methods vs nonimputed & the number of SNPs with 0 variance
og_var0_cols <- temp[, which(apply(.SD, 1, var) == 0)];
imputed_var0_cols <-imputed_dat[, which(apply(.SD,1,var) == 0)]
imputed_mean_var0_cols <- imputed_mean_dat[, which(apply(.SD,1,var) == 0)]

all.equal(imputed_var0_cols, imputed_mean_var0_cols)
```




Trying to replicate Silva-Zolezzi et al (2008)



Trying to Replicate Figure 4 in Abid et al.

\begin{align*}
X &= UDV^T\\
X^T &= \left(UDV^T\right)^T\\
    &= VDU^T
\end{align*}

So if we take the $Xu$ we should get the principle components.

Our plots don't match up well at all with the authors Figure 4. Not on the same scale

### PCA: Before and After Imputation
```{R}
setnames(temp, subset_mex_grp_names)
not_ZAP <- grep(subset_mex_grp_names, pattern = "ZAP|CEU", invert = T,   value = T)
ZAP <- grep(subset_mex_grp_names, pattern = "ZAP|CEU",   value = T)

#before imputation: 
scaled_temp <- temp[, scale(t(.SD)), .SDcols = not_ZAP]
scaled_temp <- scaled_temp[, which(!is.nan(colSums(scaled_temp)))] #remove columns with NA values

centered_temp <- temp[, scale(t(.SD), scale = F), .SDcols = not_ZAP]
centered_temp <- centered_temp[, which(!is.nan(colSums(scaled_temp)))] #remove same columns as scaled

scaled_rotated_dat <- scaled_temp %*% svd(scaled_temp, nv = 2)$v
centered_rotated_dat <- centered_temp %*% svd(centered_temp, nv = 2)$v

plot_dat <- rbind(data.table(centered_rotated_dat, substr(not_ZAP, start = 1, stop =3), "Unimputed","Centered Only"),
                  data.table(scaled_rotated_dat, substr(not_ZAP, start = 1, stop =3), "Unimputed","Scaled"))
setnames(plot_dat, c("PC1", "PC2", "State", "Imputation","Scale"))


#after imputation: distribution imputation
scaled_imp_dist <- imputed_dat[, scale(t(.SD)), .SDcols = not_ZAP]
scaled_imp_dist <- scaled_imp_dist[, which(!is.nan(colSums(scaled_imp_dist)))] #remove columns with NA values

centered_imp_dist <- imputed_dat[, scale(t(.SD), scale = F), .SDcols = not_ZAP]
centered_imp_dist <- centered_imp_dist[, which(!is.nan(colSums(scaled_imp_dist)))] #remove same columns as scaled

#after imputation: mean imputation
scaled_imp_mean <- imputed_mean_dat[, scale(t(.SD)), .SDcols = not_ZAP]
scaled_imp_mean <- scaled_imp_mean[, which(!is.nan(colSums(scaled_imp_mean)))] #remove columns with NA values

centered_imp_mean <- imputed_mean_dat[, scale(t(.SD), scale = F), .SDcols = not_ZAP]
centered_imp_mean <- centered_imp_mean[, which(!is.nan(colSums(scaled_imp_mean)))] #remove same columns as scaled

imp_dist_scaled_rotated_dat <- scaled_imp_dist %*% svd(crossprod(scaled_imp_dist), nv = 2)$v
imp_dist_centered_rotated_dat <- centered_imp_dist %*% svd(centered_imp_dist, nv = 2)$v

imp_mean_scaled_rotated_dat <- scaled_imp_mean %*% svd(scaled_imp_mean, nv = 2)$v
imp_mean_centered_rotated_dat <- centered_imp_mean %*% svd(centered_imp_mean, nv = 2)$v

plot_imp_dat <- rbind(data.table(imp_dist_scaled_rotated_dat, substr(not_ZAP, start = 1, stop =3), "Dist.","Scaled"),
                      data.table(imp_dist_centered_rotated_dat, substr(not_ZAP, start = 1, stop =3), "Dist.","Centered Only"),
                      data.table(imp_mean_scaled_rotated_dat, substr(not_ZAP, start = 1, stop =3), "Mean","Scaled"),
                      data.table(imp_mean_centered_rotated_dat, substr(not_ZAP, start = 1, stop =3), "Mean","Centered Only"))
setnames(plot_imp_dat, c("PC1", "PC2", "State", "Imputation","Scale"))


#plot both side-by-side
comb_plot_dat <- rbind(plot_dat, plot_imp_dat)

pre_post_imputation_pca <- ggplot(data = comb_plot_dat)+
  geom_jitter(aes(x = PC1, y = PC2, color = State))+
  facet_grid(Scale~Imputation)+
  labs(title = "Principal Components of Mexican Heritage")

ggsave(plot = pre_post_imputation_pca, filename = "pre_post_imputation_pca.png",height = 8.5, width = 11, units = "in")
```


### cPCA and rPCA: centered data

```{R}
# background data
centered_imp_ZAP <- scale(t(data.matrix(imputed_dat [, .SD, .SDcols = ZAP])), scale = F, center = T)
# target data
centered_imp <- scale(t(data.matrix(imputed_dat[, .SD, .SDcols = not_ZAP])), scale = F, center = T)

bg_svd <- svd(centered_imp_ZAP)$v

pcs <- centered_imp %*% svd(centered_imp,nv = 2)$v

k=25; alpha = 1;

#residual PCA
varying_bg_svd <- bg_svd[,1:k]
oc_target <- centered_imp - tcrossprod(centered_imp %*% varying_bg_svd, varying_bg_svd)
oc_projected <- oc_target %*% svd(oc_target, nv = 2)$v

#contrastive PCA
cov_to_decomp <- cov(centered_imp) - alpha*cov(centered_imp_ZAP)
contrastive <- centered_imp %*% eigen(cov_to_decomp)$vectors[,1:2]

State_Labs <- substr(not_ZAP,  start = 1, stop = 3 )

resid_pca_plot_dat <- rbind(data.table(pcs, State_Labs, "PCA"),
                            data.table(oc_projected, State_Labs, "rPCA"),
                            data.table(contrastive, State_Labs, "cPCA"))
setnames(resid_pca_plot_dat, c("PC1", "PC2", "State", "Method"))



pca_comparison_centered_imputation <- ggplot(data = resid_pca_plot_dat)+
  geom_jitter(aes(x = PC1, y = PC2, color = State))+
  facet_wrap(~Method, scales = "free")+
  labs(title = "Principal Components of Mexican Heritage after Imputation")

ggsave(plot = pca_comparison_centered_imputation, filename = "pca_comparison_centered_imputation.png",height = 8.5, width = 11, units = "in")

```

## cPCA and rPCA: scaled data

```{R}
# background data
scaled_imp_ZAP <- scale(t(data.matrix(imputed_dat [, .SD, .SDcols = ZAP])), center = T)
# target data
scaled_imp <- scale(t(data.matrix(imputed_dat[, .SD, .SDcols = not_ZAP])), center = T)

nan_cols <- sort(unique(c(which(apply(scaled_imp, 2, function(zz) sum(is.nan(zz)))>0),
  which(apply(scaled_imp_ZAP, 2, function(zz) sum(is.nan(zz)))>0))))

scaled_imp <- scaled_imp[,-nan_cols]
scaled_imp_ZAP <- scaled_imp_ZAP[, -nan_cols]

bg_svd <- svd(scaled_imp_ZAP)$v

pcs <- scaled_imp %*% svd(scaled_imp,nv = 2)$v

k=25; alpha = 1;

#residual PCA
varying_bg_svd <- bg_svd[,1:k]
oc_target <- scaled_imp - tcrossprod(scaled_imp %*% varying_bg_svd, varying_bg_svd)
oc_projected <- oc_target %*% svd(oc_target, nv = 2)$v

#contrastive PCA
cov_to_decomp <- cov(scaled_imp) - alpha*cov(scaled_imp_ZAP)
contrastive <- scaled_imp %*% eigen(cov_to_decomp)$vectors[,1:2]

State_Labs <- substr(not_ZAP,  start = 1, stop = 3 )

resid_pca_plot_dat <- rbind(data.table(pcs, State_Labs, "PCA"),
                            data.table(oc_projected, State_Labs, "rPCA"),
                            data.table(contrastive, State_Labs, "cPCA"))
setnames(resid_pca_plot_dat, c("PC1", "PC2", "State", "Method"))



pca_comparison_scaled_imputation <- ggplot(data = resid_pca_plot_dat)+
  geom_jitter(aes(x = PC1, y = PC2, color = State))+
  facet_wrap(~Method, scales = "free")+
  labs(title = "Principal Components of Mexican Heritage after Imputation and Scaling")


ggsave(plot = pca_comparison_scaled_imputation, filename = "pca_comparison_scaled_imputation.png",height = 8.5, width = 11, units = "in")

```


## cPCA 

```{R}
search_grid <- c(0, 10^(seq(-1, log10(1000), length.out = 9)))

tuning_alpha <- lapply(search_grid, function(zz){
  cov_to_decomp <- cov(centered_imp) - zz*cov(centered_imp_ZAP)
  contrastive <- centered_imp %*% eigen(cov_to_decomp)$vectors[,1:2]
  return(data.table(contrastive, State_Labs, zz))
})

tuning_alpha_plot <- rbindlist(tuning_alpha)
setnames(tuning_alpha_plot, c("PCA.1", "PCA.2", "State", "alpha"))

cPCA_mexican_diff_alpha <- ggplot(data = tuning_alpha_plot)+
  geom_point(aes(x = PCA.1, y = PCA.2, color = State), alpha = 0.7)+
  facet_wrap(~alpha, scales = "free", nrow = 2)+
  theme(legend.position = "bottom")+
  labs(title = "Mexican State Data: Contrastive PCA with different alpha")

ggsave(plot = cPCA_mexican_diff_alpha, filename = "cPCA_mexican_diff_alpha.png",height = 8.5, width = 11, units = "in")
```



plot out for various different number of bg_components saved for all 6 mexican states

```{r}
diff_bg_list <- lapply(seq(2,30, by = 2), function(zz) {
  rPCA_temp <- rPCA(target = centered_imp, bg = centered_imp_ZAP, standardize = F, return_all = F, bg_components = zz, n_components = 2)
  list_temp <- rbind(data.table(rPCA_temp, substr(not_ZAP, start = 1, stop =3), zz))
  setnames(list_temp, c("PC1", "PC2", "State", "bg_components"))
  return(list_temp)}
  )

resid_pca_plot_dat_all <- rbindlist(diff_bg_list)

rpca_imputation_all <- ggplot(data = resid_pca_plot_dat_all)+
  geom_point(aes(x = PC1, y = PC2, color = State))+
  facet_wrap(~bg_components, scales = "free", nrow = 3)+
  labs(title = "Residual Principal Components of Mexican Heritage for varying bg_components")+
  theme(legend.position = "bottom")

ggsave(plot = rpca_imputation_all, filename = "rpca_imputation_all.png",height = 8.5, width = 11, units = "in")
```

plot out for various different number of bg_components saved, VER excluded (as done in Abid et al.)

```{R}
not_ZAP_VER <- grep(mex_grp_names, pattern = "ZAP|VER", invert = T,   value = T)

centered_imp_not_VER <- scale(t(data.matrix(imputed_dat[, .SD, .SDcols = not_ZAP_VER])), scale = F, center = T)

diff_bg_list_no_VER <- lapply(seq(2,30, by = 2), function(zz){
varying_bg_svd <- bg_svd[,1:k]
oc_target <- centered_imp_not_VER - tcrossprod(centered_imp_not_VER %*% varying_bg_svd, varying_bg_svd)
oc_projected <- oc_target %*% svd(oc_target, nv = 2)$v
  list_temp <- rbind(data.table(oc_projected, substr(not_ZAP_VER, start = 1, stop = 3), zz))  
  setnames(list_temp, c("PC1", "PC2", "State", "bg_components"))
  return(list_temp)
  })

resid_pca_plot_dat_all_no_VER <- rbindlist(diff_bg_list_no_VER)

rpca_imputation_all_no_VER <- ggplot(data = resid_pca_plot_dat_all_no_VER)+
  geom_point(aes(x = PC1, y = PC2, color = State))+
  facet_wrap(~bg_components, scales = "free", nrow = 3)+
  labs(title = "Residual Principal Components of Mexican Heritage for varying bg_components \n VER Not Included")+
  theme(legend.position = "bottom")

ggsave(plot = rpca_imputation_all_no_VER, filename = "rpca_imputation_all_no_VER.png",height = 8.5, width = 11, units = "in")
```



rPCA on this data seems to produce the same figures?? Why?? code works cause I tried it on mouse data and recreated the same plots.
plots generated are very similar to just normal PCA. Why?? 


next steps:
LDA on the projected space?
take out VER, cause it's not in the cPCA analysis

```{R}

search_grid <- c(0, 10^(seq(-1, log10(1000), length.out = 19)))

diff_alpha_list <- lapply(search_grid, function(zz) {
  cPCA_temp <- cPCA(target = centered_imp, bg = centered_imp_ZAP, standardize = F, return_all = F, alpha = zz, n_components = 2)
  list_temp <- rbind(data.table(cPCA_temp, substr(not_ZAP, start = 1, stop =3), zz))
  setnames(list_temp, c("cPC1", "cPC2", "State", "alpha"))
  return(list_temp)}
  )

cpca_plot_dat_all <- rbindlist(diff_alpha_list)

cpca_imputation_all <- ggplot(data = cpca_plot_dat_all)+
  geom_point(aes(x = cPC1, y = cPC2, color = State))+
  facet_wrap(~alpha, scales = "free", nrow = 3)+
  labs(title = "Contrastive Principal Components of Mexican Heritage for varying alpha")+
  theme(legend.position = "bottom")

ggsave(plot = cpca_imputation_all, filename = "cpca_imputation_all.png",height = 8.5, width = 11, units = "in")



```

LDA
